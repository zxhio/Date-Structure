---
layout: default
title:  "TCP UDP IP 协议的封装"
date:   2018-04-14 17:50:00
categories: main
---

**数据的封装**
- <a href = "#udp"> UDP 封装 </a>
- <a href = "#tcp"> TCP 封装 </a>
- <a href = "#ip"> IP 封装 </a>
- <a href = "#checksum"> 检验和算法 </a>

 当应用程序用TCP传送数据时,数据被传送入协议栈中,然后逐一通过每一层直到被当作一串比特流送入网络 

![](img/data_push.jpg)
> 注: `UDP`数据`TCP`数据基本一致. 唯一不同的是`UDP`传给`IP`的信息单元称作`UDP`数据报

***
其中每一层对收到的数据都要增加一些首部信息(有时还要增加尾部信息)
> 注： 4个字节的32bit值的传输次序：首先是0-7字节，其次是8-15, 然后是16-23, 最后是24-31 bit，这种传输次序称作 `big-ending`（大端）字节序，或者网络字节序

**<a name = "udp"> UDP 封装 </a>**
-  ![](img/udp.jpg) 
- 端口号表示发送进程和接受进程
- `UDP`长度字段指的是`UDP`首部和`UDP`数据的字节长度, 最小为`8`(发送一份`0`字节的`UDP数据报`)
- `UDP`<a href = "#checksum">检验和</a>覆盖`UDP`首部和`UDP`数据

**<a name = "tcp"> TCP 封装 </a>**
- ![](img/tcp.jpg)
- 每个`TCP`段都有包含源端和目的端的端口号，用于寻找发端和收端应用进程,这两个端加上`IP`首部的源端`IP`地址和目的端`IP`地址唯一确定一个`TCP`连接。
- 序号用于标识从`TCP`发端向`TCP`收端发送的数据字节流，表示在这个报文段中的第一个数据字节。 如果将字节流看作在两个应用程序间的单向流动，则`TCP`用序号对每个序号进行计数。
- 确认序号包含发送确认的一端所期望收到的下一个序号，确认序号应当是上次成功收到的数据字节序号加一，只有`ACK`标志为1时，确认字段序列才有效。
- 首部长度给出首部中`32-bit`字的数目。这个值存在是由于选项字段的长度是可变的，这个字段占4bit，所以`TCP`最多有60字节的首部，没有选项字段，正常长度是20字节。
- 6 个标志位
    - URG ，紧急指针（urgent pointer）有效
    - ACK ，确认序号有效
    - PSH ，接收方法应该尽快将这个报文段交给应用层
    - RST ，重新连接
    - SYN ，同步序号用来发起一个连接
    - FIN ， 发端完成任务
- 窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节，窗口大小为16 bit字段，因而窗口大小为65535个字节。
- 检验和覆盖了`整个TCP`报文段：TCP首部和TCP数据。
- URG标志置1时紧急指针才有效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号，TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。
- 最常见的可选字段是最长报文大小，又为 MSS（Maximum Segment Size）。
- TCP 报文段数据部分是可选的

**<a name = "ip"> IP 封装</a>**
- ![](img/ip.jpg)
- 协议版本号，IPv4 IPv6
- 首部长度指的是首部占`32-bit`字的数目，包括任何选项，最长60字节。
- 服务类型字段包括一个3-bit的优先权子字段（现已被忽略），4 bit的TOS子字段和1 bit未用但必须置0，4 bit 的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用，如果所有bit置0，就为一般服务。

| 应用程序 | 最小时延 | 最大吞吐量 | 最高可靠性 | 最小费用 | 0x |
| :--- | :---: | :---: | :---: | :---: | :---: |
| Telnet/Rlogin | 1 | 0 | 0 | 0 | 0x10 |
| FTP (控制，数据，任意数据块) | 1 0 0 | 0 1 1 | 0 0 0 | 0 0 0 | 0x10 0x08 0x08 |
| TFTP | 1 | 0 | 0 | 0 | 0x10 |
| SMTP (命令阶段, 数据阶段) | 1 0 | 0 1 | 0 0 | 0 0 | 0x10 0x08 |
| DNS (UDP查询，TCP查询，区域传输) | 1 0 0 | 0 0 1 | 0 0 0 | 0 0 0 | 0x10 0x00 0x08 |
- 总长度字段是整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段就可以知道IP数据报中数据内容的起始位置和长度。总长度也是IP首部中必要的内容，以为一些数据链路需要填充数据以达到最小长度。
- 标识符字段唯一的标识主机发送的每一份数据，通常发一份报文它的值就加1。
- TTL（time-to-live）生存时间字段设置了数据报可以经过的`最多路由器数`，指定了数据报的生存时间。TTL的初始值由`源主机`设置（通常为32或者64），一旦经过一个处理它的路由器就减1。当该字段为0时，数据报就被丢弃，并发送ICMP报文通知源主机。
- 首部检验和字段是根据`IP首部`计算的检验和码，不对首部后面的数据进行计算。ICMP、IGMP、UDP、和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。
- 每一份IP数据报都含有源IP地址和目的IP地址
- 选项
    - 安全和处理限制
    - 记录路径
    - 时间戳
    - 宽松的源站选路
    - 严格的源站选路
    > 选项字段都是以 32-bit作为界限，在必要的时候需要对其进行0填充，保证IP首部始终是32-bit的整数倍（首部长度字段所要求）

**<a name = "checksum"> 检验和算法 </a>**
- TCP UDP 为了验证还有增加了两个伪首部
- 计算检验和（发送方）
    - 首先把检验和字段置0
    - 对检验字段（IP只有首部，TCP/UDP等为首部和数据）中每个16-bit进行二进制反码求和
    - 结果存于检验和字段
- 计算检验和（接受方）
    - 由于接受方在计算过程中包含了发送方存在首部的检验和，因此，如果在传输过程中没有发送任何差错，那么接受方计算的结果应该为`全1`
- C 的简单实现
    ``` C
    unsigned short ipCksum(unsigned short *addr,int len)
    {
        unsigned long sum;

        for (sum=0; len > 0; len--)
            sum += *addr++;

        sum = (sum >> 16) + (sum & 0xffff);
        sum += (sum >> 16);

        return ~sum;
    }
    ```